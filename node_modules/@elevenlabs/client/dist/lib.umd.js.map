{"version":3,"file":"lib.umd.js","sources":["../src/BaseConversation.ts","../src/utils/events.ts","../src/utils/connection.ts","../src/utils/compatibility.ts","../src/utils/applyDelay.ts","../src/TextConversation.ts","../src/utils/audio.ts","../src/utils/createWorkletModuleLoader.ts","../src/utils/rawAudioProcessor.ts","../src/utils/input.ts","../src/utils/audioConcatProcessor.ts","../src/utils/output.ts","../src/VoiceConversation.ts","../src/index.ts","../src/utils/postOverallFeedback.ts"],"sourcesContent":["import {\n  Connection,\n  DisconnectionDetails,\n  type OnDisconnectCallback,\n  type SessionConfig,\n} from \"./utils/connection\";\nimport {\n  AgentAudioEvent,\n  AgentResponseEvent,\n  ClientToolCallEvent,\n  IncomingSocketEvent,\n  InternalTentativeAgentResponseEvent,\n  InterruptionEvent,\n  UserTranscriptionEvent,\n} from \"./utils/events\";\nimport type { InputConfig } from \"./utils/input\";\n\nexport type Role = \"user\" | \"ai\";\n\nexport type Mode = \"speaking\" | \"listening\";\n\nexport type Status =\n  | \"connecting\"\n  | \"connected\"\n  | \"disconnecting\"\n  | \"disconnected\";\n\nexport type Options = SessionConfig &\n  Callbacks &\n  ClientToolsConfig &\n  InputConfig;\n\nexport type PartialOptions = SessionConfig &\n  Partial<Callbacks> &\n  Partial<ClientToolsConfig> &\n  Partial<InputConfig>;\n\nexport type ClientToolsConfig = {\n  clientTools: Record<\n    string,\n    (\n      parameters: any\n    ) => Promise<string | number | void> | string | number | void\n  >;\n};\n\nexport type Callbacks = {\n  onConnect: (props: { conversationId: string }) => void;\n  // internal debug events, not to be used\n  onDebug: (props: any) => void;\n  onDisconnect: OnDisconnectCallback;\n  onError: (message: string, context?: any) => void;\n  onMessage: (props: { message: string; source: Role }) => void;\n  onAudio: (base64Audio: string) => void;\n  onModeChange: (prop: { mode: Mode }) => void;\n  onStatusChange: (prop: { status: Status }) => void;\n  onCanSendFeedbackChange: (prop: { canSendFeedback: boolean }) => void;\n  onUnhandledClientToolCall?: (\n    params: ClientToolCallEvent[\"client_tool_call\"]\n  ) => void;\n};\n\nconst EMPTY_FREQUENCY_DATA = new Uint8Array(0);\n\nexport class BaseConversation {\n  protected lastInterruptTimestamp: number = 0;\n  protected mode: Mode = \"listening\";\n  protected status: Status = \"connecting\";\n  protected volume: number = 1;\n  protected currentEventId: number = 1;\n  protected lastFeedbackEventId: number = 1;\n  protected canSendFeedback: boolean = false;\n\n  protected static getFullOptions(partialOptions: PartialOptions): Options {\n    return {\n      clientTools: {},\n      onConnect: () => {},\n      onDebug: () => {},\n      onDisconnect: () => {},\n      onError: () => {},\n      onMessage: () => {},\n      onAudio: () => {},\n      onModeChange: () => {},\n      onStatusChange: () => {},\n      onCanSendFeedbackChange: () => {},\n      ...partialOptions,\n    };\n  }\n\n  protected constructor(\n    protected readonly options: Options,\n    protected readonly connection: Connection\n  ) {\n    this.options.onConnect({ conversationId: connection.conversationId });\n    this.connection.onMessage(this.onMessage);\n    this.connection.onDisconnect(this.endSessionWithDetails);\n    this.updateStatus(\"connected\");\n  }\n\n  public endSession() {\n    return this.endSessionWithDetails({ reason: \"user\" });\n  }\n\n  private endSessionWithDetails = async (details: DisconnectionDetails) => {\n    if (this.status !== \"connected\" && this.status !== \"connecting\") return;\n    this.updateStatus(\"disconnecting\");\n    await this.handleEndSession();\n    this.updateStatus(\"disconnected\");\n    this.options.onDisconnect(details);\n  };\n\n  protected async handleEndSession() {\n    this.connection.close();\n  }\n\n  protected updateMode(mode: Mode) {\n    if (mode !== this.mode) {\n      this.mode = mode;\n      this.options.onModeChange({ mode });\n    }\n  }\n\n  protected updateStatus(status: Status) {\n    if (status !== this.status) {\n      this.status = status;\n      this.options.onStatusChange({ status });\n    }\n  }\n\n  protected updateCanSendFeedback() {\n    const canSendFeedback = this.currentEventId !== this.lastFeedbackEventId;\n    if (this.canSendFeedback !== canSendFeedback) {\n      this.canSendFeedback = canSendFeedback;\n      this.options.onCanSendFeedbackChange({ canSendFeedback });\n    }\n  }\n\n  protected handleInterruption(event: InterruptionEvent) {\n    if (event.interruption_event) {\n      this.lastInterruptTimestamp = event.interruption_event.event_id;\n    }\n  }\n\n  protected handleAgentResponse(event: AgentResponseEvent) {\n    this.options.onMessage({\n      source: \"ai\",\n      message: event.agent_response_event.agent_response,\n    });\n  }\n\n  protected handleUserTranscript(event: UserTranscriptionEvent) {\n    this.options.onMessage({\n      source: \"user\",\n      message: event.user_transcription_event.user_transcript,\n    });\n  }\n\n  protected handleTentativeAgentResponse(\n    event: InternalTentativeAgentResponseEvent\n  ) {\n    this.options.onDebug({\n      type: \"tentative_agent_response\",\n      response:\n        event.tentative_agent_response_internal_event.tentative_agent_response,\n    });\n  }\n\n  protected async handleClientToolCall(event: ClientToolCallEvent) {\n    if (\n      this.options.clientTools.hasOwnProperty(event.client_tool_call.tool_name)\n    ) {\n      try {\n        const result =\n          (await this.options.clientTools[event.client_tool_call.tool_name](\n            event.client_tool_call.parameters\n          )) ?? \"Client tool execution successful.\"; // default client-tool call response\n\n        // The API expects result to be a string, so we need to convert it if it's not already a string\n        const formattedResult =\n          typeof result === \"object\" ? JSON.stringify(result) : String(result);\n\n        this.connection.sendMessage({\n          type: \"client_tool_result\",\n          tool_call_id: event.client_tool_call.tool_call_id,\n          result: formattedResult,\n          is_error: false,\n        });\n      } catch (e) {\n        this.onError(\n          \"Client tool execution failed with following error: \" +\n            (e as Error)?.message,\n          {\n            clientToolName: event.client_tool_call.tool_name,\n          }\n        );\n        this.connection.sendMessage({\n          type: \"client_tool_result\",\n          tool_call_id: event.client_tool_call.tool_call_id,\n          result: \"Client tool execution failed: \" + (e as Error)?.message,\n          is_error: true,\n        });\n      }\n    } else {\n      if (this.options.onUnhandledClientToolCall) {\n        this.options.onUnhandledClientToolCall(event.client_tool_call);\n\n        return;\n      }\n\n      this.onError(\n        `Client tool with name ${event.client_tool_call.tool_name} is not defined on client`,\n        {\n          clientToolName: event.client_tool_call.tool_name,\n        }\n      );\n      this.connection.sendMessage({\n        type: \"client_tool_result\",\n        tool_call_id: event.client_tool_call.tool_call_id,\n        result: `Client tool with name ${event.client_tool_call.tool_name} is not defined on client`,\n        is_error: true,\n      });\n    }\n  }\n\n  protected handleAudio(event: AgentAudioEvent) {}\n\n  private onMessage = async (parsedEvent: IncomingSocketEvent) => {\n    switch (parsedEvent.type) {\n      case \"interruption\": {\n        this.handleInterruption(parsedEvent);\n        return;\n      }\n      case \"agent_response\": {\n        this.handleAgentResponse(parsedEvent);\n        return;\n      }\n      case \"user_transcript\": {\n        this.handleUserTranscript(parsedEvent);\n        return;\n      }\n      case \"internal_tentative_agent_response\": {\n        this.handleTentativeAgentResponse(parsedEvent);\n        return;\n      }\n      case \"client_tool_call\": {\n        await this.handleClientToolCall(parsedEvent);\n        return;\n      }\n      case \"audio\": {\n        this.handleAudio(parsedEvent);\n        return;\n      }\n\n      case \"ping\": {\n        this.connection.sendMessage({\n          type: \"pong\",\n          event_id: parsedEvent.ping_event.event_id,\n        });\n        // parsedEvent.ping_event.ping_ms can be used on client side, for example\n        // to warn if ping is too high that experience might be degraded.\n        return;\n      }\n\n      // unhandled events are expected to be internal events\n      default: {\n        this.options.onDebug(parsedEvent);\n        return;\n      }\n    }\n  };\n\n  private onError(message: string, context?: any) {\n    console.error(message, context);\n    this.options.onError(message, context);\n  }\n\n  public getId() {\n    return this.connection.conversationId;\n  }\n\n  public isOpen() {\n    return this.status === \"connected\";\n  }\n\n  public setVolume = ({ volume }: { volume: number }) => {\n    this.volume = volume;\n  };\n\n  public setMicMuted(isMuted: boolean) {}\n\n  public getInputByteFrequencyData() {\n    return EMPTY_FREQUENCY_DATA;\n  }\n\n  public getOutputByteFrequencyData() {\n    return EMPTY_FREQUENCY_DATA;\n  }\n\n  public getInputVolume() {\n    return 0;\n  }\n\n  public getOutputVolume() {\n    return 0;\n  }\n\n  public sendFeedback(like: boolean) {\n    if (!this.canSendFeedback) {\n      console.warn(\n        this.lastFeedbackEventId === 0\n          ? \"Cannot send feedback: the conversation has not started yet.\"\n          : \"Cannot send feedback: feedback has already been sent for the current response.\"\n      );\n      return;\n    }\n\n    this.connection.sendMessage({\n      type: \"feedback\",\n      score: like ? \"like\" : \"dislike\",\n      event_id: this.currentEventId,\n    });\n    this.lastFeedbackEventId = this.currentEventId;\n    this.updateCanSendFeedback();\n  }\n\n  public sendContextualUpdate(text: string) {\n    this.connection.sendMessage({\n      type: \"contextual_update\",\n      text,\n    });\n  }\n\n  public sendUserMessage(text: string) {\n    this.connection.sendMessage({\n      type: \"user_message\",\n      text,\n    });\n  }\n\n  public sendUserActivity() {\n    this.connection.sendMessage({\n      type: \"user_activity\",\n    });\n  }\n\n  public sendMCPToolApprovalResult(toolCallId: string, isApproved: boolean) {\n    this.connection.sendMessage({\n      type: \"mcp_tool_approval_result\",\n      tool_call_id: toolCallId,\n      is_approved: isApproved,\n    });\n  }\n}\n","import { Language } from \"./connection\";\n\nexport type UserTranscriptionEvent = {\n  type: \"user_transcript\";\n  user_transcription_event: { user_transcript: string };\n};\nexport type AgentResponseEvent = {\n  type: \"agent_response\";\n  agent_response_event: { agent_response: string };\n};\nexport type AgentAudioEvent = {\n  type: \"audio\";\n  audio_event: {\n    audio_base_64: string;\n    event_id: number;\n  };\n};\nexport type InterruptionEvent = {\n  type: \"interruption\";\n  interruption_event: {\n    event_id: number;\n  };\n};\nexport type InternalTentativeAgentResponseEvent = {\n  type: \"internal_tentative_agent_response\";\n  tentative_agent_response_internal_event: {\n    tentative_agent_response: string;\n  };\n};\nexport type ConfigEvent = {\n  type: \"conversation_initiation_metadata\";\n  conversation_initiation_metadata_event: {\n    conversation_id: string;\n    agent_output_audio_format: string;\n    user_input_audio_format?: string;\n  };\n};\nexport type PingEvent = {\n  type: \"ping\";\n  ping_event: {\n    event_id: number;\n    ping_ms?: number;\n  };\n};\nexport type ClientToolCallEvent = {\n  type: \"client_tool_call\";\n  client_tool_call: {\n    tool_name: string;\n    tool_call_id: string;\n    parameters: any;\n    expects_response: boolean;\n  };\n};\n\n// TODO correction missing\nexport type IncomingSocketEvent =\n  | UserTranscriptionEvent\n  | AgentResponseEvent\n  | AgentAudioEvent\n  | InterruptionEvent\n  | InternalTentativeAgentResponseEvent\n  | ConfigEvent\n  | PingEvent\n  | ClientToolCallEvent;\n\nexport type PongEvent = {\n  type: \"pong\";\n  event_id: number;\n};\nexport type UserAudioEvent = {\n  user_audio_chunk: string;\n};\nexport type UserFeedbackEvent = {\n  type: \"feedback\";\n  score: \"like\" | \"dislike\";\n  event_id: number;\n};\nexport type ClientToolResultEvent = {\n  type: \"client_tool_result\";\n  tool_call_id: string;\n  result: any;\n  is_error: boolean;\n};\nexport type InitiationClientDataEvent = {\n  type: \"conversation_initiation_client_data\";\n  conversation_config_override?: {\n    agent?: {\n      prompt?: {\n        prompt?: string;\n      };\n      first_message?: string;\n      language?: Language;\n    };\n    tts?: {\n      voice_id?: string;\n    };\n    conversation?: {\n      text_only?: boolean;\n    };\n  };\n  custom_llm_extra_body?: any;\n  dynamic_variables?: Record<string, string | number | boolean>;\n};\nexport type ContextualUpdateEvent = {\n  type: \"contextual_update\";\n  text: string;\n};\nexport type UserMessageEvent = {\n  type: \"user_message\";\n  text: string;\n};\nexport type UserActivityEvent = {\n  type: \"user_activity\";\n};\nexport type MCPToolApprovalResultEvent = {\n  type: \"mcp_tool_approval_result\";\n  tool_call_id: string;\n  is_approved: boolean;\n};\nexport type OutgoingSocketEvent =\n  | PongEvent\n  | UserAudioEvent\n  | InitiationClientDataEvent\n  | UserFeedbackEvent\n  | ClientToolResultEvent\n  | ContextualUpdateEvent\n  | UserMessageEvent\n  | UserActivityEvent\n  | MCPToolApprovalResultEvent;\n\nexport function isValidSocketEvent(event: any): event is IncomingSocketEvent {\n  return !!event.type;\n}\n","import {\n  InitiationClientDataEvent,\n  ConfigEvent,\n  isValidSocketEvent,\n  OutgoingSocketEvent,\n  IncomingSocketEvent,\n} from \"./events\";\n\nconst MAIN_PROTOCOL = \"convai\";\n\nexport type Language =\n  | \"en\"\n  | \"ja\"\n  | \"zh\"\n  | \"de\"\n  | \"hi\"\n  | \"fr\"\n  | \"ko\"\n  | \"pt\"\n  | \"pt-br\"\n  | \"it\"\n  | \"es\"\n  | \"id\"\n  | \"nl\"\n  | \"tr\"\n  | \"pl\"\n  | \"sv\"\n  | \"bg\"\n  | \"ro\"\n  | \"ar\"\n  | \"cs\"\n  | \"el\"\n  | \"fi\"\n  | \"ms\"\n  | \"da\"\n  | \"ta\"\n  | \"uk\"\n  | \"ru\"\n  | \"hu\"\n  | \"hr\"\n  | \"sk\"\n  | \"no\"\n  | \"vi\";\nexport type DelayConfig = {\n  default: number;\n  android?: number;\n  ios?: number;\n};\nexport type SessionConfig = {\n  origin?: string;\n  authorization?: string;\n  overrides?: {\n    agent?: {\n      prompt?: {\n        prompt?: string;\n      };\n      firstMessage?: string;\n      language?: Language;\n    };\n    tts?: {\n      voiceId?: string;\n    };\n    conversation?: {\n      textOnly?: boolean;\n    };\n  };\n  customLlmExtraBody?: any;\n  dynamicVariables?: Record<string, string | number | boolean>;\n  useWakeLock?: boolean;\n  connectionDelay?: DelayConfig;\n  textOnly?: boolean;\n} & (\n  | { signedUrl: string; agentId?: undefined }\n  | { agentId: string; signedUrl?: undefined }\n);\nexport type FormatConfig = {\n  format: \"pcm\" | \"ulaw\";\n  sampleRate: number;\n};\nexport type DisconnectionDetails =\n  | {\n      reason: \"error\";\n      message: string;\n      context: Event;\n    }\n  | {\n      reason: \"agent\";\n      context: CloseEvent;\n    }\n  | {\n      reason: \"user\";\n    };\nexport type OnDisconnectCallback = (details: DisconnectionDetails) => void;\nexport type OnMessageCallback = (event: IncomingSocketEvent) => void;\n\nconst WSS_API_ORIGIN = \"wss://api.elevenlabs.io\";\nconst WSS_API_PATHNAME = \"/v1/convai/conversation?agent_id=\";\n\nexport class Connection {\n  public static async create(config: SessionConfig): Promise<Connection> {\n    let socket: WebSocket | null = null;\n\n    try {\n      const origin = config.origin ?? WSS_API_ORIGIN;\n      const url = config.signedUrl\n        ? config.signedUrl\n        : origin + WSS_API_PATHNAME + config.agentId;\n\n      const protocols = [MAIN_PROTOCOL];\n      if (config.authorization) {\n        protocols.push(`bearer.${config.authorization}`);\n      }\n      socket = new WebSocket(url, protocols);\n      const conversationConfig = await new Promise<\n        ConfigEvent[\"conversation_initiation_metadata_event\"]\n      >((resolve, reject) => {\n        socket!.addEventListener(\n          \"open\",\n          () => {\n            const overridesEvent: InitiationClientDataEvent = {\n              type: \"conversation_initiation_client_data\",\n            };\n\n            if (config.overrides) {\n              overridesEvent.conversation_config_override = {\n                agent: {\n                  prompt: config.overrides.agent?.prompt,\n                  first_message: config.overrides.agent?.firstMessage,\n                  language: config.overrides.agent?.language,\n                },\n                tts: {\n                  voice_id: config.overrides.tts?.voiceId,\n                },\n                conversation: {\n                  text_only: config.overrides.conversation?.textOnly,\n                },\n              };\n            }\n\n            if (config.customLlmExtraBody) {\n              overridesEvent.custom_llm_extra_body = config.customLlmExtraBody;\n            }\n\n            if (config.dynamicVariables) {\n              overridesEvent.dynamic_variables = config.dynamicVariables;\n            }\n\n            socket?.send(JSON.stringify(overridesEvent));\n          },\n          { once: true }\n        );\n        socket!.addEventListener(\"error\", event => {\n          // In case the error event is followed by a close event, we want the\n          // latter to be the one that rejects the promise as it contains more\n          // useful information.\n          setTimeout(() => reject(event), 0);\n        });\n        socket!.addEventListener(\"close\", reject);\n        socket!.addEventListener(\n          \"message\",\n          (event: MessageEvent) => {\n            const message = JSON.parse(event.data);\n\n            if (!isValidSocketEvent(message)) {\n              return;\n            }\n\n            if (message.type === \"conversation_initiation_metadata\") {\n              resolve(message.conversation_initiation_metadata_event);\n            } else {\n              console.warn(\n                \"First received message is not conversation metadata.\"\n              );\n            }\n          },\n          { once: true }\n        );\n      });\n\n      const {\n        conversation_id,\n        agent_output_audio_format,\n        user_input_audio_format,\n      } = conversationConfig;\n\n      const inputFormat = parseFormat(user_input_audio_format ?? \"pcm_16000\");\n      const outputFormat = parseFormat(agent_output_audio_format);\n\n      return new Connection(socket, conversation_id, inputFormat, outputFormat);\n    } catch (error) {\n      socket?.close();\n      throw error;\n    }\n  }\n\n  private queue: IncomingSocketEvent[] = [];\n  private disconnectionDetails: DisconnectionDetails | null = null;\n  private onDisconnectCallback: OnDisconnectCallback | null = null;\n  private onMessageCallback: OnMessageCallback | null = null;\n\n  private constructor(\n    public readonly socket: WebSocket,\n    public readonly conversationId: string,\n    public readonly inputFormat: FormatConfig,\n    public readonly outputFormat: FormatConfig\n  ) {\n    this.socket.addEventListener(\"error\", event => {\n      // In case the error event is followed by a close event, we want the\n      // latter to be the one that disconnects the session as it contains more\n      // useful information.\n      setTimeout(\n        () =>\n          this.disconnect({\n            reason: \"error\",\n            message: \"The connection was closed due to a socket error.\",\n            context: event,\n          }),\n        0\n      );\n    });\n    this.socket.addEventListener(\"close\", event => {\n      this.disconnect(\n        event.code === 1000\n          ? {\n              reason: \"agent\",\n              context: event,\n            }\n          : {\n              reason: \"error\",\n              message:\n                event.reason || \"The connection was closed by the server.\",\n              context: event,\n            }\n      );\n    });\n    this.socket.addEventListener(\"message\", event => {\n      try {\n        const parsedEvent = JSON.parse(event.data);\n        if (!isValidSocketEvent(parsedEvent)) {\n          return;\n        }\n\n        if (this.onMessageCallback) {\n          this.onMessageCallback(parsedEvent);\n        } else {\n          this.queue.push(parsedEvent);\n        }\n      } catch (_) {}\n    });\n  }\n\n  public close() {\n    this.socket.close();\n  }\n\n  public sendMessage(message: OutgoingSocketEvent) {\n    this.socket.send(JSON.stringify(message));\n  }\n\n  public onMessage(callback: OnMessageCallback) {\n    this.onMessageCallback = callback;\n    const queue = this.queue;\n    this.queue = [];\n\n    if (queue.length > 0) {\n      // Make sure the queue is flushed after the constructors finishes and\n      // classes are initialized.\n      queueMicrotask(() => {\n        queue.forEach(callback);\n      });\n    }\n  }\n\n  public onDisconnect(callback: OnDisconnectCallback) {\n    this.onDisconnectCallback = callback;\n    const details = this.disconnectionDetails;\n    if (details) {\n      // Make sure the event is triggered after the constructors finishes and\n      // classes are initialized.\n      queueMicrotask(() => {\n        callback(details);\n      });\n    }\n  }\n\n  private disconnect(details: DisconnectionDetails) {\n    if (!this.disconnectionDetails) {\n      this.disconnectionDetails = details;\n      this.onDisconnectCallback?.(details);\n    }\n  }\n}\n\nfunction parseFormat(format: string): FormatConfig {\n  const [formatPart, sampleRatePart] = format.split(\"_\");\n  if (![\"pcm\", \"ulaw\"].includes(formatPart)) {\n    throw new Error(`Invalid format: ${format}`);\n  }\n\n  const sampleRate = parseInt(sampleRatePart);\n  if (isNaN(sampleRate)) {\n    throw new Error(`Invalid sample rate: ${sampleRatePart}`);\n  }\n\n  return {\n    format: formatPart as FormatConfig[\"format\"],\n    sampleRate,\n  };\n}\n","export function isIosDevice() {\n  return (\n    [\n      \"iPad Simulator\",\n      \"iPhone Simulator\",\n      \"iPod Simulator\",\n      \"iPad\",\n      \"iPhone\",\n      \"iPod\",\n    ].includes(navigator.platform) ||\n    // iPad on iOS 13 detection\n    (navigator.userAgent.includes(\"Mac\") && \"ontouchend\" in document)\n  );\n}\n\nexport function isAndroidDevice() {\n  return /android/i.test(navigator.userAgent);\n}\n","import { isAndroidDevice, isIosDevice } from \"./compatibility\";\nimport { DelayConfig } from \"./connection\";\n\nexport async function applyDelay(\n  delayConfig: DelayConfig = {\n    default: 0,\n    // Give the Android AudioManager enough time to switch to the correct audio mode\n    android: 3_000,\n  }\n) {\n  let delay = delayConfig.default;\n  if (isAndroidDevice()) {\n    delay = delayConfig.android ?? delay;\n  } else if (isIosDevice()) {\n    delay = delayConfig.ios ?? delay;\n  }\n\n  if (delay > 0) {\n    await new Promise(resolve => setTimeout(resolve, delay));\n  }\n}\n","import { Connection } from \"./utils/connection\";\nimport { applyDelay } from \"./utils/applyDelay\";\nimport { BaseConversation, PartialOptions } from \"./BaseConversation\";\n\nexport class TextConversation extends BaseConversation {\n  public static async startSession(\n    options: PartialOptions\n  ): Promise<TextConversation> {\n    const fullOptions = BaseConversation.getFullOptions(options);\n\n    fullOptions.onStatusChange({ status: \"connecting\" });\n    fullOptions.onCanSendFeedbackChange({ canSendFeedback: false });\n\n    let connection: Connection | null = null;\n    try {\n      await applyDelay(fullOptions.connectionDelay);\n      connection = await Connection.create(options);\n      return new TextConversation(fullOptions, connection);\n    } catch (error) {\n      fullOptions.onStatusChange({ status: \"disconnected\" });\n      connection?.close();\n      throw error;\n    }\n  }\n}\n","export function arrayBufferToBase64(b: ArrayBufferLike) {\n  const buffer = new Uint8Array(b);\n  // @ts-ignore\n  const base64Data = window.btoa(String.fromCharCode(...buffer));\n  return base64Data;\n}\n\nexport function base64ToArrayBuffer(base64: string): ArrayBuffer {\n  const binaryString = window.atob(base64);\n  const len = binaryString.length;\n  const bytes = new Uint8Array(len);\n  for (let i = 0; i < len; i++) {\n    bytes[i] = binaryString.charCodeAt(i);\n  }\n  return bytes.buffer;\n}\n","const URLCache = new Map<string, string>();\n\nexport function createWorkletModuleLoader(name: string, sourceCode: string) {\n  return async (worklet: AudioWorklet) => {\n    const url = URLCache.get(name);\n    if (url) {\n      return worklet.addModule(url);\n    }\n\n    const blob = new Blob([sourceCode], { type: \"application/javascript\" });\n    const blobURL = URL.createObjectURL(blob);\n    try {\n      await worklet.addModule(blobURL);\n      URLCache.set(name, blobURL);\n      return;\n    } catch {\n      URL.revokeObjectURL(blobURL);\n    }\n\n    try {\n      // Attempting to start a conversation in Safari inside an iframe will\n      // throw a CORS error because the blob:// protocol is considered\n      // cross-origin. In such cases, fall back to using a base64 data URL:\n      const base64 = btoa(sourceCode);\n      const moduleURL = `data:application/javascript;base64,${base64}`;\n      await worklet.addModule(moduleURL);\n      URLCache.set(name, moduleURL);\n    } catch (error) {\n      throw new Error(\n        `Failed to load the ${name} worklet module. Make sure the browser supports AudioWorklets.`\n      );\n    }\n  };\n}\n","/*\n * ulaw encoding logic taken from the wavefile library\n * https://github.com/rochars/wavefile/blob/master/lib/codecs/mulaw.js\n */\n\nimport { createWorkletModuleLoader } from \"./createWorkletModuleLoader\";\n\nexport const loadRawAudioProcessor = createWorkletModuleLoader(\n  \"raw-audio-processor\",\n  // language=JavaScript\n  `\nconst BIAS = 0x84;\nconst CLIP = 32635;\nconst encodeTable = [\n  0,0,1,1,2,2,2,2,3,3,3,3,3,3,3,3,\n  4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,\n  5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,\n  5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,\n  6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,\n  6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,\n  6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,\n  6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,\n  7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,\n  7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,\n  7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,\n  7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,\n  7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,\n  7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,\n  7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,\n  7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7\n];\n\nfunction encodeSample(sample) {\n  let sign;\n  let exponent;\n  let mantissa;\n  let muLawSample;\n  sign = (sample >> 8) & 0x80;\n  if (sign !== 0) sample = -sample;\n  sample = sample + BIAS;\n  if (sample > CLIP) sample = CLIP;\n  exponent = encodeTable[(sample>>7) & 0xFF];\n  mantissa = (sample >> (exponent+3)) & 0x0F;\n  muLawSample = ~(sign | (exponent << 4) | mantissa);\n  \n  return muLawSample;\n}\n\nclass RawAudioProcessor extends AudioWorkletProcessor {\n  constructor() {\n    super();\n              \n    this.port.onmessage = ({ data }) => {\n      switch (data.type) {\n        case \"setFormat\":\n          this.isMuted = false;\n          this.buffer = []; // Initialize an empty buffer\n          this.bufferSize = data.sampleRate / 4;\n          this.format = data.format;\n\n          if (globalThis.LibSampleRate && sampleRate !== data.sampleRate) {\n            globalThis.LibSampleRate.create(1, sampleRate, data.sampleRate).then(resampler => {\n              this.resampler = resampler;\n            });\n          }\n          break;\n        case \"setMuted\":\n          this.isMuted = data.isMuted;\n          break;\n      }\n    };\n  }\n  process(inputs) {\n    if (!this.buffer) {\n      return true;\n    }\n    \n    const input = inputs[0]; // Get the first input node\n    if (input.length > 0) {\n      let channelData = input[0]; // Get the first channel's data\n\n      // Resample the audio if necessary\n      if (this.resampler) {\n        channelData = this.resampler.full(channelData);\n      }\n\n      // Add channel data to the buffer\n      this.buffer.push(...channelData);\n      // Get max volume \n      let sum = 0.0;\n      for (let i = 0; i < channelData.length; i++) {\n        sum += channelData[i] * channelData[i];\n      }\n      const maxVolume = Math.sqrt(sum / channelData.length);\n      // Check if buffer size has reached or exceeded the threshold\n      if (this.buffer.length >= this.bufferSize) {\n        const float32Array = this.isMuted \n          ? new Float32Array(this.buffer.length)\n          : new Float32Array(this.buffer);\n\n        let encodedArray = this.format === \"ulaw\"\n          ? new Uint8Array(float32Array.length)\n          : new Int16Array(float32Array.length);\n\n        // Iterate through the Float32Array and convert each sample to PCM16\n        for (let i = 0; i < float32Array.length; i++) {\n          // Clamp the value to the range [-1, 1]\n          let sample = Math.max(-1, Math.min(1, float32Array[i]));\n\n          // Scale the sample to the range [-32768, 32767]\n          let value = sample < 0 ? sample * 32768 : sample * 32767;\n          if (this.format === \"ulaw\") {\n            value = encodeSample(Math.round(value));\n          }\n\n          encodedArray[i] = value;\n        }\n\n        // Send the buffered data to the main script\n        this.port.postMessage([encodedArray, maxVolume]);\n\n        // Clear the buffer after sending\n        this.buffer = [];\n      }\n    }\n    return true; // Continue processing\n  }\n}\nregisterProcessor(\"raw-audio-processor\", RawAudioProcessor);\n`\n);\n","import { loadRawAudioProcessor } from \"./rawAudioProcessor\";\nimport { FormatConfig } from \"./connection\";\nimport { isIosDevice } from \"./compatibility\";\n\nexport type InputConfig = {\n  preferHeadphonesForIosDevices?: boolean;\n};\n\nconst LIBSAMPLERATE_JS =\n  \"https://cdn.jsdelivr.net/npm/@alexanderolsen/libsamplerate-js@2.1.2/dist/libsamplerate.worklet.js\";\n\nexport class Input {\n  public static async create({\n    sampleRate,\n    format,\n    preferHeadphonesForIosDevices,\n  }: FormatConfig & InputConfig): Promise<Input> {\n    let context: AudioContext | null = null;\n    let inputStream: MediaStream | null = null;\n\n    try {\n      const options: MediaTrackConstraints = {\n        sampleRate: { ideal: sampleRate },\n        echoCancellation: { ideal: true },\n        noiseSuppression: { ideal: true },\n      };\n\n      if (isIosDevice() && preferHeadphonesForIosDevices) {\n        const availableDevices =\n          await window.navigator.mediaDevices.enumerateDevices();\n        const idealDevice = availableDevices.find(\n          d =>\n            // cautious to include \"bluetooth\" in the search\n            // as might trigger bluetooth speakers\n            d.kind === \"audioinput\" &&\n            [\"airpod\", \"headphone\", \"earphone\"].find(keyword =>\n              d.label.toLowerCase().includes(keyword)\n            )\n        );\n        if (idealDevice) {\n          options.deviceId = { ideal: idealDevice.deviceId };\n        }\n      }\n\n      const supportsSampleRateConstraint =\n        navigator.mediaDevices.getSupportedConstraints().sampleRate;\n\n      context = new window.AudioContext(\n        supportsSampleRateConstraint ? { sampleRate } : {}\n      );\n      const analyser = context.createAnalyser();\n      if (!supportsSampleRateConstraint) {\n        await context.audioWorklet.addModule(LIBSAMPLERATE_JS);\n      }\n      await loadRawAudioProcessor(context.audioWorklet);\n\n      inputStream = await navigator.mediaDevices.getUserMedia({\n        audio: options,\n      });\n\n      const source = context.createMediaStreamSource(inputStream);\n      const worklet = new AudioWorkletNode(context, \"raw-audio-processor\");\n      worklet.port.postMessage({ type: \"setFormat\", format, sampleRate });\n\n      source.connect(analyser);\n      analyser.connect(worklet);\n\n      await context.resume();\n\n      return new Input(context, analyser, worklet, inputStream);\n    } catch (error) {\n      inputStream?.getTracks().forEach(track => track.stop());\n      context?.close();\n      throw error;\n    }\n  }\n\n  private constructor(\n    public readonly context: AudioContext,\n    public readonly analyser: AnalyserNode,\n    public readonly worklet: AudioWorkletNode,\n    public readonly inputStream: MediaStream\n  ) {}\n\n  public async close() {\n    this.inputStream.getTracks().forEach(track => track.stop());\n    await this.context.close();\n  }\n\n  public setMuted(isMuted: boolean) {\n    this.worklet.port.postMessage({ type: \"setMuted\", isMuted });\n  }\n}\n","/*\n * ulaw decoding logic taken from the wavefile library\n * https://github.com/rochars/wavefile/blob/master/lib/codecs/mulaw.js\n */\n\nimport { createWorkletModuleLoader } from \"./createWorkletModuleLoader\";\n\nexport const loadAudioConcatProcessor = createWorkletModuleLoader(\n  \"audio-concat-processor\",\n  // language=JavaScript\n  `\nconst decodeTable = [0,132,396,924,1980,4092,8316,16764];\n\nexport function decodeSample(muLawSample) {\n  let sign;\n  let exponent;\n  let mantissa;\n  let sample;\n  muLawSample = ~muLawSample;\n  sign = (muLawSample & 0x80);\n  exponent = (muLawSample >> 4) & 0x07;\n  mantissa = muLawSample & 0x0F;\n  sample = decodeTable[exponent] + (mantissa << (exponent+3));\n  if (sign !== 0) sample = -sample;\n\n  return sample;\n}\n\nclass AudioConcatProcessor extends AudioWorkletProcessor {\n  constructor() {\n    super();\n    this.buffers = []; // Initialize an empty buffer\n    this.cursor = 0;\n    this.currentBuffer = null;\n    this.wasInterrupted = false;\n    this.finished = false;\n    \n    this.port.onmessage = ({ data }) => {\n      switch (data.type) {\n        case \"setFormat\":\n          this.format = data.format;\n          break;\n        case \"buffer\":\n          this.wasInterrupted = false;\n          this.buffers.push(\n            this.format === \"ulaw\"\n              ? new Uint8Array(data.buffer)\n              : new Int16Array(data.buffer)\n          );\n          break;\n        case \"interrupt\":\n          this.wasInterrupted = true;\n          break;\n        case \"clearInterrupted\":\n          if (this.wasInterrupted) {\n            this.wasInterrupted = false;\n            this.buffers = [];\n            this.currentBuffer = null;\n          }\n      }\n    };\n  }\n  process(_, outputs) {\n    let finished = false;\n    const output = outputs[0][0];\n    for (let i = 0; i < output.length; i++) {\n      if (!this.currentBuffer) {\n        if (this.buffers.length === 0) {\n          finished = true;\n          break;\n        }\n        this.currentBuffer = this.buffers.shift();\n        this.cursor = 0;\n      }\n\n      let value = this.currentBuffer[this.cursor];\n      if (this.format === \"ulaw\") {\n        value = decodeSample(value);\n      }\n      output[i] = value / 32768;\n      this.cursor++;\n\n      if (this.cursor >= this.currentBuffer.length) {\n        this.currentBuffer = null;\n      }\n    }\n\n    if (this.finished !== finished) {\n      this.finished = finished;\n      this.port.postMessage({ type: \"process\", finished });\n    }\n\n    return true; // Continue processing\n  }\n}\n\nregisterProcessor(\"audio-concat-processor\", AudioConcatProcessor);\n`\n);\n","import { loadAudioConcatProcessor } from \"./audioConcatProcessor\";\nimport { FormatConfig } from \"./connection\";\n\nexport class Output {\n  public static async create({\n    sampleRate,\n    format,\n  }: FormatConfig): Promise<Output> {\n    let context: AudioContext | null = null;\n    try {\n      context = new AudioContext({ sampleRate });\n      const analyser = context.createAnalyser();\n      const gain = context.createGain();\n      gain.connect(analyser);\n      analyser.connect(context.destination);\n      await loadAudioConcatProcessor(context.audioWorklet);\n      const worklet = new AudioWorkletNode(context, \"audio-concat-processor\");\n      worklet.port.postMessage({ type: \"setFormat\", format });\n      worklet.connect(gain);\n\n      await context.resume();\n\n      return new Output(context, analyser, gain, worklet);\n    } catch (error) {\n      context?.close();\n      throw error;\n    }\n  }\n\n  private constructor(\n    public readonly context: AudioContext,\n    public readonly analyser: AnalyserNode,\n    public readonly gain: GainNode,\n    public readonly worklet: AudioWorkletNode\n  ) {}\n\n  public async close() {\n    await this.context.close();\n  }\n}\n","import { arrayBufferToBase64, base64ToArrayBuffer } from \"./utils/audio\";\nimport { Input } from \"./utils/input\";\nimport { Output } from \"./utils/output\";\nimport { Connection } from \"./utils/connection\";\nimport { AgentAudioEvent, InterruptionEvent } from \"./utils/events\";\nimport { applyDelay } from \"./utils/applyDelay\";\nimport { BaseConversation, Options, PartialOptions } from \"./BaseConversation\";\n\nexport class VoiceConversation extends BaseConversation {\n  public static async startSession(\n    options: PartialOptions\n  ): Promise<VoiceConversation> {\n    const fullOptions = BaseConversation.getFullOptions(options);\n\n    fullOptions.onStatusChange({ status: \"connecting\" });\n    fullOptions.onCanSendFeedbackChange({ canSendFeedback: false });\n\n    let input: Input | null = null;\n    let connection: Connection | null = null;\n    let output: Output | null = null;\n    let preliminaryInputStream: MediaStream | null = null;\n\n    let wakeLock: WakeLockSentinel | null = null;\n    if (options.useWakeLock ?? true) {\n      try {\n        wakeLock = await navigator.wakeLock.request(\"screen\");\n      } catch (e) {\n        // Wake Lock is not required for the conversation to work\n      }\n    }\n\n    try {\n      // some browsers won't allow calling getSupportedConstraints or enumerateDevices\n      // before getting approval for microphone access\n      preliminaryInputStream = await navigator.mediaDevices.getUserMedia({\n        audio: true,\n      });\n\n      await applyDelay(fullOptions.connectionDelay);\n      connection = await Connection.create(options);\n      [input, output] = await Promise.all([\n        Input.create({\n          ...connection.inputFormat,\n          preferHeadphonesForIosDevices: options.preferHeadphonesForIosDevices,\n        }),\n        Output.create(connection.outputFormat),\n      ]);\n\n      preliminaryInputStream?.getTracks().forEach(track => track.stop());\n      preliminaryInputStream = null;\n\n      return new VoiceConversation(\n        fullOptions,\n        connection,\n        input,\n        output,\n        wakeLock\n      );\n    } catch (error) {\n      fullOptions.onStatusChange({ status: \"disconnected\" });\n      preliminaryInputStream?.getTracks().forEach(track => track.stop());\n      connection?.close();\n      await input?.close();\n      await output?.close();\n      try {\n        await wakeLock?.release();\n        wakeLock = null;\n      } catch (e) {}\n      throw error;\n    }\n  }\n\n  private inputFrequencyData?: Uint8Array;\n  private outputFrequencyData?: Uint8Array;\n\n  protected constructor(\n    options: Options,\n    connection: Connection,\n    public readonly input: Input,\n    public readonly output: Output,\n    public wakeLock: WakeLockSentinel | null\n  ) {\n    super(options, connection);\n    this.input.worklet.port.onmessage = this.onInputWorkletMessage;\n    this.output.worklet.port.onmessage = this.onOutputWorkletMessage;\n  }\n\n  protected override async handleEndSession() {\n    await super.handleEndSession();\n    try {\n      await this.wakeLock?.release();\n      this.wakeLock = null;\n    } catch (e) {}\n\n    await this.input.close();\n    await this.output.close();\n  }\n\n  protected override handleInterruption(event: InterruptionEvent) {\n    super.handleInterruption(event);\n    this.fadeOutAudio();\n  }\n\n  protected override handleAudio(event: AgentAudioEvent) {\n    if (this.lastInterruptTimestamp <= event.audio_event.event_id) {\n      this.options.onAudio(event.audio_event.audio_base_64);\n      this.addAudioBase64Chunk(event.audio_event.audio_base_64);\n      this.currentEventId = event.audio_event.event_id;\n      this.updateCanSendFeedback();\n      this.updateMode(\"speaking\");\n    }\n  }\n\n  private onInputWorkletMessage = (event: MessageEvent): void => {\n    const rawAudioPcmData = event.data[0];\n\n    // TODO: When supported, maxVolume can be used to avoid sending silent audio\n    // const maxVolume = event.data[1];\n\n    if (this.status === \"connected\") {\n      this.connection.sendMessage({\n        user_audio_chunk: arrayBufferToBase64(rawAudioPcmData.buffer),\n      });\n    }\n  };\n\n  private onOutputWorkletMessage = ({ data }: MessageEvent): void => {\n    if (data.type === \"process\") {\n      this.updateMode(data.finished ? \"listening\" : \"speaking\");\n    }\n  };\n\n  private addAudioBase64Chunk = (chunk: string) => {\n    this.output.gain.gain.value = this.volume;\n    this.output.worklet.port.postMessage({ type: \"clearInterrupted\" });\n    this.output.worklet.port.postMessage({\n      type: \"buffer\",\n      buffer: base64ToArrayBuffer(chunk),\n    });\n  };\n\n  private fadeOutAudio = () => {\n    // mute agent\n    this.updateMode(\"listening\");\n    this.output.worklet.port.postMessage({ type: \"interrupt\" });\n    this.output.gain.gain.exponentialRampToValueAtTime(\n      0.0001,\n      this.output.context.currentTime + 2\n    );\n\n    // reset volume back\n    setTimeout(() => {\n      this.output.gain.gain.value = this.volume;\n      this.output.worklet.port.postMessage({ type: \"clearInterrupted\" });\n    }, 2000); // Adjust the duration as needed\n  };\n\n  private calculateVolume = (frequencyData: Uint8Array) => {\n    if (frequencyData.length === 0) {\n      return 0;\n    }\n\n    // TODO: Currently this averages all frequencies, but we should probably\n    // bias towards the frequencies that are more typical for human voice\n    let volume = 0;\n    for (let i = 0; i < frequencyData.length; i++) {\n      volume += frequencyData[i] / 255;\n    }\n    volume /= frequencyData.length;\n\n    return volume < 0 ? 0 : volume > 1 ? 1 : volume;\n  };\n\n  public setMicMuted(isMuted: boolean) {\n    this.input.setMuted(isMuted);\n  }\n\n  public getInputByteFrequencyData() {\n    this.inputFrequencyData ??= new Uint8Array(\n      this.input.analyser.frequencyBinCount\n    );\n    this.input.analyser.getByteFrequencyData(this.inputFrequencyData);\n    return this.inputFrequencyData;\n  }\n\n  public getOutputByteFrequencyData() {\n    this.outputFrequencyData ??= new Uint8Array(\n      this.output.analyser.frequencyBinCount\n    );\n    this.output.analyser.getByteFrequencyData(this.outputFrequencyData);\n    return this.outputFrequencyData;\n  }\n\n  public getInputVolume() {\n    return this.calculateVolume(this.getInputByteFrequencyData());\n  }\n\n  public getOutputVolume() {\n    return this.calculateVolume(this.getOutputByteFrequencyData());\n  }\n}\n","import { BaseConversation, PartialOptions } from \"./BaseConversation\";\nimport { TextConversation } from \"./TextConversation\";\nimport { VoiceConversation } from \"./VoiceConversation\";\n\nexport type {\n  Mode,\n  Role,\n  Options,\n  PartialOptions,\n  ClientToolsConfig,\n  Callbacks,\n  Status,\n} from \"./BaseConversation\";\nexport type { InputConfig } from \"./utils/input\";\nexport type { IncomingSocketEvent } from \"./utils/events\";\nexport type {\n  SessionConfig,\n  DisconnectionDetails,\n  Language,\n} from \"./utils/connection\";\nexport { postOverallFeedback } from \"./utils/postOverallFeedback\";\n\nexport class Conversation extends BaseConversation {\n  public static startSession(options: PartialOptions): Promise<Conversation> {\n    return options.textOnly\n      ? TextConversation.startSession(options)\n      : VoiceConversation.startSession(options);\n  }\n}\n","const HTTPS_API_ORIGIN = \"https://api.elevenlabs.io\";\n\nexport function postOverallFeedback(\n  conversationId: string,\n  like: boolean,\n  origin: string = HTTPS_API_ORIGIN\n) {\n  return fetch(`${origin}/v1/convai/conversations/${conversationId}/feedback`, {\n    method: \"POST\",\n    body: JSON.stringify({\n      feedback: like ? \"like\" : \"dislike\",\n    }),\n    headers: {\n      \"Content-Type\": \"application/json\",\n    },\n  });\n}\n"],"names":["EMPTY_FREQUENCY_DATA","Uint8Array","BaseConversation","options","connection","_this3","_this","this","_this2","lastInterruptTimestamp","mode","status","volume","currentEventId","lastFeedbackEventId","canSendFeedback","endSessionWithDetails","details","Promise","resolve","updateStatus","handleEndSession","then","onDisconnect","e","reject","onMessage","parsedEvent","type","handleInterruption","handleAgentResponse","handleUserTranscript","handleTentativeAgentResponse","handleClientToolCall","handleAudio","sendMessage","event_id","ping_event","onDebug","setVolume","_ref","onConnect","conversationId","getFullOptions","partialOptions","_extends","clientTools","onError","onAudio","onModeChange","onStatusChange","onCanSendFeedbackChange","_proto","prototype","endSession","reason","close","updateMode","updateCanSendFeedback","event","interruption_event","source","message","agent_response_event","agent_response","user_transcription_event","user_transcript","response","tentative_agent_response_internal_event","tentative_agent_response","_this5","hasOwnProperty","client_tool_call","tool_name","_temp","parameters","result","formattedResult","JSON","stringify","String","tool_call_id","is_error","_catch","clientToolName","onUnhandledClientToolCall","context","console","error","getId","isOpen","setMicMuted","isMuted","getInputByteFrequencyData","getOutputByteFrequencyData","getInputVolume","getOutputVolume","sendFeedback","like","score","warn","sendContextualUpdate","text","sendUserMessage","sendUserActivity","sendMCPToolApprovalResult","toolCallId","isApproved","is_approved","isValidSocketEvent","Connection","socket","inputFormat","outputFormat","queue","disconnectionDetails","onDisconnectCallback","onMessageCallback","addEventListener","setTimeout","disconnect","code","parse","data","push","_","create","config","origin","_config$origin","url","signedUrl","agentId","protocols","authorization","WebSocket","_socket","_config$overrides$age","_config$overrides$age2","_config$overrides$age3","_config$overrides$tts","_config$overrides$con","overridesEvent","overrides","conversation_config_override","agent","prompt","first_message","firstMessage","language","tts","voice_id","voiceId","conversation","text_only","textOnly","customLlmExtraBody","custom_llm_extra_body","dynamicVariables","dynamic_variables","send","once","conversation_initiation_metadata_event","conversationConfig","conversation_id","agent_output_audio_format","user_input_audio_format","parseFormat","_socket2","callback","length","queueMicrotask","forEach","_this$onDisconnectCal","call","format","_format$split","split","formatPart","sampleRatePart","includes","Error","sampleRate","parseInt","isNaN","isIosDevice","navigator","platform","userAgent","document","applyDelay","delayConfig","default","android","_delayConfig$android","delay","test","_delayConfig$ios","ios","TextConversation","_BaseConversation","apply","arguments","_inheritsLoose","startSession","fullOptions","connectionDelay","_Connection$create","_connection","base64ToArrayBuffer","base64","binaryString","window","atob","len","bytes","i","charCodeAt","buffer","URLCache","Map","createWorkletModuleLoader","name","sourceCode","worklet","_exit","_temp2","_result","moduleURL","btoa","addModule","set","get","blob","Blob","blobURL","URL","createObjectURL","revokeObjectURL","loadRawAudioProcessor","Input","analyser","inputStream","preferHeadphonesForIosDevices","_temp4","audioWorklet","mediaDevices","getUserMedia","audio","_navigator$mediaDevic","createMediaStreamSource","AudioWorkletNode","port","postMessage","connect","resume","supportsSampleRateConstraint","getSupportedConstraints","AudioContext","createAnalyser","ideal","echoCancellation","noiseSuppression","_temp3","enumerateDevices","availableDevices","idealDevice","find","d","kind","keyword","label","toLowerCase","deviceId","_inputStream","_context","getTracks","track","stop","setMuted","loadAudioConcatProcessor","Output","gain","createGain","destination","VoiceConversation","input","output","wakeLock","inputFrequencyData","outputFrequencyData","onInputWorkletMessage","b","user_audio_chunk","fromCharCode","onOutputWorkletMessage","finished","addAudioBase64Chunk","chunk","value","fadeOutAudio","exponentialRampToValueAtTime","currentTime","calculateVolume","frequencyData","onmessage","_temp5","preliminaryInputStream","all","_Promise$all","_preliminaryInputStre","_preliminaryInputStre2","_input","_output","_wakeLock","release","_options$useWakeLock","useWakeLock","request","_navigator$wakeLock$r","_temp7","_temp6","_this2$wakeLock","audio_event","audio_base_64","_this$inputFrequencyD","frequencyBinCount","getByteFrequencyData","Conversation","fetch","method","body","feedback","headers"],"mappings":"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"}